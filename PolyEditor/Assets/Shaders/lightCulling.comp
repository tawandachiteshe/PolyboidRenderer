#version 450 core

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct Plane
{
	vec3 Normal;
	float distanceFromOrigin;
};

struct Frustum
{
	Plane planes[4]; // left, right, top, bottom frustum planes.
};


struct Sphere
{
    vec3 c;   // Center point.
    float  r;   // Radius.
};

struct Cone
{
    vec3 T;   // Cone tip.
    float  h;   // Height of the cone.
    vec3 d;   // Direction of the cone.
    float  r;   // bottom radius of the cone.
};

struct PointLight
{
	float Position[3];
	float Color[3];
	float Distance;
	float Energy;
};


struct SpotLight
{
	float Position[3];
	float Direction[3];
	float Color[3];
	float InnerAngle;
	float OuterAngle;
	float Distance;
	float Energy;
	
};

struct DirectionalLight
{
	float Direction[3];
	float Color[3];
	float Energy;
};

layout(binding = 0) uniform sampler2D uDepthTexture;
layout(rg32ui, binding = 1) uniform uimage2D u_oLightGrid;
layout(rg32ui, binding = 2) uniform uimage2D u_tLightGrid;


#define BLOCK_SIZE 16
uniform mat4 uInverseProjection;

uniform int uPointLightsCount;
uniform int uSpotLightsCount;
uniform int uDirectionLightsCount;

shared uint uMinDepth;
shared uint uMaxDepth;
shared Frustum GroupFrustum;

// Opaque geometry light lists.
shared uint o_LightCount;
shared uint o_LightIndexStartOffset;
shared uint o_LightList[1024];
 
// Transparent geometry light lists.
shared uint t_LightCount;
shared uint t_LightIndexStartOffset;
shared uint t_LightList[1024];

layout(std430, binding = 0) readonly buffer Frustums {
  Frustum in_Frustums[];
};


layout(std430, binding = 2) readonly buffer PointLights {
  PointLight in_PointLights[];
};


layout(std430, binding = 3) readonly buffer SpotLights {
  SpotLight in_SpotLights[];
};

layout(std430, binding = 4) readonly buffer DirLights {
  DirectionalLight in_DirLights[];
};

layout(std430, binding = 5) buffer oLightIndex {
  uint o_LightIndexCounter[];
};

layout(std430, binding = 6) buffer tLightIndex {
  uint t_LightIndexCounter [];
};

layout(std430, binding = 7) buffer oLightIndexList  {
  uint o_LightIndexList[];
};

layout(std430, binding = 8) buffer tLightIndexList  {
  uint t_LightIndexList[];
};


vec3 float3ToVec3(float p[3])
{
	return vec3(p[0], p[1], p[2]);
}




bool SphereInsidePlane(Sphere sphere, Plane plane )
{
    return dot( plane.Normal, sphere.c ) - plane.distanceFromOrigin < -sphere.r;
}

// Check to see of a light is partially contained within the frustum.
bool SphereInsideFrustum( Sphere sphere, Frustum frustum, float zNear, float zFar )
{
    bool result = true;
 
    // First check depth
    // Note: Here, the view vector points in the -Z axis so the 
    // far depth value will be approaching -infinity.
    if ( sphere.c.z - sphere.r > zNear || sphere.c.z + sphere.r < zFar )
    {
        result = false;
    }
 
    // Then check frustum planes
    for ( int i = 0; i < 4 && result; i++ )
    {
        if ( SphereInsidePlane( sphere, frustum.planes[i] ) )
        {
            result = false;
        }
    }
 
    return result;
}


// Check to see if a point is fully behind (inside the negative halfspace of) a plane.
bool PointInsidePlane( vec3 p, Plane plane )
{
    return dot( plane.Normal, p ) - plane.distanceFromOrigin < 0;
}

// Check to see if a cone if fully behind (inside the negative halfspace of) a plane.
// Source: Real-time collision detection, Christer Ericson (2005)
bool ConeInsidePlane( Cone cone, Plane plane )
{
    // Compute the farthest point on the end of the cone to the positive space of the plane.
    vec3 m = cross( cross( plane.Normal, cone.d ), cone.d );
    vec3 Q = cone.T + cone.d * cone.h - m * cone.r;
 
    // The cone is in the negative halfspace of the plane if both
    // the tip of the cone and the farthest point on the end of the cone to the 
    // positive halfspace of the plane are both inside the negative halfspace 
    // of the plane.
    return PointInsidePlane( cone.T, plane ) && PointInsidePlane( Q, plane );
}

bool ConeInsideFrustum( Cone cone, Frustum frustum, float zNear, float zFar )
{
    bool result = true;
 
    Plane nearPlane = { vec3( 0, 0, -1 ), -zNear };
    Plane farPlane = { vec3( 0, 0, 1 ), zFar };
 
    // First check the near and far clipping planes.
    if ( ConeInsidePlane( cone, nearPlane ) || ConeInsidePlane( cone, farPlane ) )
    {
        result = false;
    }
 
    // Then check frustum planes
    for ( int i = 0; i < 4 && result; i++ )
    {
        if ( ConeInsidePlane( cone, frustum.planes[i] ) )
        {
            result = false;
        }
    }
 
    return result;
}

// Add the light to the visible light list for opaque geometry.
void o_AppendLight( uint lightIndex )
{
    uint index; // Index into the visible lights array.
    index = atomicAdd( o_LightCount, uint(1));
    if ( index < 1024 )
    {
        o_LightList[index] = lightIndex;
    }
}
 
// Add the light to the visible light list for transparent geometry.
void t_AppendLight( uint lightIndex )
{
    uint index; // Index into the visible lights array.
    index = atomicAdd( t_LightCount, 1);
    if ( index < 1024 )
    {
        t_LightList[index] = lightIndex;
    }
}


vec4 ClipToView( vec4 clip )
{
    // View space position.
    vec4 view = uInverseProjection * clip;
    // Perspective projection.
    view = view / view.w;
    return view;
}


void main()
{
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

    float depthf = texture(uDepthTexture, texelCoord).r;
    uint depthu = uint(depthf);

    if(gl_LocalInvocationIndex == 0)
    {
        uMinDepth = 0xffffffff;
        uMaxDepth = 0;
        o_LightCount = 0;
        t_LightCount = 0;
        GroupFrustum = in_Frustums[gl_WorkGroupID.x + ( gl_WorkGroupID.y * gl_NumWorkGroups.x )];
    }

    groupMemoryBarrier();

    atomicMin(uMinDepth, depthu);
    atomicMin(uMaxDepth, depthu);
     
    groupMemoryBarrier();

    float fMinDepth = float( uMinDepth );
    float fMaxDepth = float( uMaxDepth );

    // Convert depth values to view space.
    float minDepthVS = ClipToView( vec4( 0, 0, fMinDepth, 1 ) ).z;
    float maxDepthVS = ClipToView( vec4( 0, 0, fMaxDepth, 1 ) ).z;
    float nearClipVS = ClipToView( vec4( 0, 0, 0, 1 ) ).z;
 
    // Clipping plane for minimum depth value 
    // (used for testing lights within the bounds of opaque geometry).
    Plane minPlane = { vec3( 0, 0, -1 ), -minDepthVS };
 
    //point lights
    for ( uint i = gl_LocalInvocationIndex; i < uPointLightsCount; i += BLOCK_SIZE * BLOCK_SIZE )
    {
        Sphere sphere = { float3ToVec3(in_PointLights[i].Position), in_PointLights[i].Distance };
        if(SphereInsideFrustum(sphere, GroupFrustum, nearClipVS, maxDepthVS))
        {
            t_AppendLight(i);

           if ( !SphereInsidePlane( sphere, minPlane ) )
           {
              // Add light to light list for opaque geometry.
              o_AppendLight( i );
           }

        }
    }

    for ( uint i = gl_LocalInvocationIndex; i < uSpotLightsCount; i += BLOCK_SIZE * BLOCK_SIZE )
    {
        
        SpotLight light = in_SpotLights[i];
        
         float coneRadius = tan( radians( light.InnerAngle ) ) * light.Distance;
         Cone cone = { float3ToVec3(light.Position).xyz, light.Distance, float3ToVec3(light.Direction).xyz, coneRadius };
         if ( ConeInsideFrustum( cone, GroupFrustum, nearClipVS, maxDepthVS ) )
         {
             // Add light to light list for transparent geometry.
             t_AppendLight( i );
 
             if ( !ConeInsidePlane( cone, minPlane ) )
             {
                 // Add light to light list for opaque geometry.
                 o_AppendLight( i );
             }
          }
       
    }

    for ( uint i = gl_LocalInvocationIndex; i < uDirectionLightsCount; i += BLOCK_SIZE * BLOCK_SIZE )
    {
         t_AppendLight( i );
         o_AppendLight( i );
    }

     if ( gl_LocalInvocationIndex == 0 )
    {
        // Update light grid for opaque geometry.
        o_LightIndexStartOffset = atomicAdd( o_LightIndexCounter[0], o_LightCount);
        imageStore(u_oLightGrid, ivec2(gl_WorkGroupID.xy), ivec4(vec2( o_LightIndexStartOffset, o_LightCount ), 0, 1));
 
        // Update light grid for transparent geometry.
        t_LightIndexStartOffset = atomicAdd( t_LightIndexCounter[0], t_LightCount);
        imageStore(u_tLightGrid, ivec2(gl_WorkGroupID.xy), ivec4(vec2( t_LightIndexStartOffset, t_LightCount ), 0, 1));
    }

    groupMemoryBarrier();

      // Now update the light index list (all threads).
    // For opaque geometry.
    for (uint i = gl_LocalInvocationIndex; i < o_LightCount; i += BLOCK_SIZE * BLOCK_SIZE )
    {
        o_LightIndexList[o_LightIndexStartOffset + i] = o_LightList[i];
    }
    // For transparent geometry.
    for ( uint i = gl_LocalInvocationIndex; i < t_LightCount; i += BLOCK_SIZE * BLOCK_SIZE )
    {
        t_LightIndexList[t_LightIndexStartOffset + i] = t_LightList[i];
    }

}