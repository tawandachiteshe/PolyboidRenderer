#version 450 core

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct Plane
{
	vec3 Normal;
	float distanceFromOrigin;
};

struct Frustum
{
	Plane planes[4]; // left, right, top, bottom frustum planes.
};


struct Sphere
{
    vec3 c;   // Center point.
    float  r;   // Radius.
};

struct Cone
{
    vec3 T;   // Cone tip.
    float  h;   // Height of the cone.
    vec3 d;   // Direction of the cone.
    float  r;   // bottom radius of the cone.
};

struct PointLight
{
	float Position[3];
    float PositionVS[3];
	float Color[3];
	float Distance;
	float Energy;
    bool Enabled;
};


struct SpotLight
{
	float Position[3];
	float PositionVS[3];
	float Direction[3];
	float DirectionVS[3];
	float Color[3];
	float InnerAngle;
	float OuterAngle;
	float Distance;
	float Energy;
    bool Enabled;
};
	
struct LightCounter
{
	uint Point;
    uint Spot;
    uint Dir;
};

struct LightIndex
{
	uint Point;
    uint Spot;
    uint Dir;
};


struct DirectionalLight
{
	float Direction[3];
    float DirectionVS[3];
	float Color[3];
	float Energy;
    bool Enabled;
};

layout(binding = 0) uniform sampler2D uDepthTexture;
layout(rg32ui, binding = 1) uniform uimage2D u_tPointLightGrid;
layout(rg32ui, binding = 2) uniform uimage2D u_tSpotLightGrid;
layout(rg32ui, binding = 3) uniform uimage2D u_tDirLightGrid;

layout(rg32ui, binding = 4) uniform uimage2D u_oPointLightGrid;
layout(rg32ui, binding = 5) uniform uimage2D u_oSpotLightGrid;
layout(rg32ui, binding = 6) uniform uimage2D u_oDirLightGrid;

layout(rgba32f, binding = 7) uniform image2D u_tLightHeatMap;

struct LightCount
{
    uint Point;
    uint Spot;
    uint Dir;
};



#define BLOCK_SIZE 16

layout(binding = 0) uniform CameraData 
{
    uniform mat4 uInverseProjection;
};




shared uint uMinDepth;
shared uint uMaxDepth;
shared Frustum GroupFrustum;

// Opaque geometry light lists.
shared LightCounter o_LightCount;
shared LightCounter o_LightIndexStartOffset;
shared LightCounter o_LightList[1024];
 
// Transparent geometry light lists.
shared LightCounter t_LightCount;
shared LightCounter t_LightIndexStartOffset;
shared LightCounter t_LightList[1024];

layout(std430, binding = 0) readonly buffer Frustums {
  Frustum in_Frustums[];
};


layout(std430, binding = 1) buffer PointLights {
  PointLight in_PointLights[];
};


layout(std430, binding = 2) readonly buffer SpotLights {
  SpotLight in_SpotLights[];
};

layout(std430, binding = 3) readonly buffer DirLights {
  DirectionalLight in_DirLights[];
};

layout (std430, binding = 4) buffer LightCountSSBO{
    LightCount lightCount;
};


layout(std430, binding = 5) buffer oLightIndex {
  uint o_LightIndexCounter[3];
};

layout(std430, binding = 6) buffer tLightIndex {
  uint t_LightIndexCounter [3];
};

layout(std430, binding = 7) buffer oLightIndexList  {
  LightIndex o_LightIndexList[];
};

layout(std430, binding = 8) buffer tLightIndexList  {
  LightIndex t_LightIndexList[];
};


vec3 float3ToVec3(float p[3])
{
	return vec3(p[0], p[1], p[2]);
}




bool SphereInsidePlane(Sphere sphere, Plane plane )
{
    return dot( plane.Normal, sphere.c ) - plane.distanceFromOrigin < -sphere.r;
}

// Check to see of a light is partially contained within the frustum.
bool SphereInsideFrustum( Sphere sphere, Frustum frustum, float zNear, float zFar )
{
    bool result = true;
 
    // First check depth
    // Note: Here, the view vector points in the -Z axis so the 
    // far depth value will be approaching -infinity.
    if ( sphere.c.z - sphere.r > zNear || sphere.c.z + sphere.r < zFar )
    {
        result = false;
    }
 
    // Then check frustum planes
    for ( int i = 0; i < 4 && result; i++ )
    {
        if ( SphereInsidePlane( sphere, frustum.planes[i] ) )
        {
            result = false;
        }
    }
 
    return result;
}


// Check to see if a point is fully behind (inside the negative halfspace of) a plane.
bool PointInsidePlane( vec3 p, Plane plane )
{
    return dot( plane.Normal, p ) - plane.distanceFromOrigin < 0;
}

// Check to see if a cone if fully behind (inside the negative halfspace of) a plane.
// Source: Real-time collision detection, Christer Ericson (2005)
bool ConeInsidePlane( Cone cone, Plane plane )
{
    // Compute the farthest point on the end of the cone to the positive space of the plane.
    vec3 m = cross( cross( plane.Normal, cone.d ), cone.d );
    vec3 Q = cone.T + cone.d * cone.h - m * cone.r;
 
    // The cone is in the negative halfspace of the plane if both
    // the tip of the cone and the farthest point on the end of the cone to the 
    // positive halfspace of the plane are both inside the negative halfspace 
    // of the plane.
    return PointInsidePlane( cone.T, plane ) && PointInsidePlane( Q, plane );
}

bool ConeInsideFrustum( Cone cone, Frustum frustum, float zNear, float zFar )
{
    bool result = true;
 
    Plane nearPlane = { vec3( 0, 0, -1 ), -zNear };
    Plane farPlane = { vec3( 0, 0, 1 ), zFar };
 
    // First check the near and far clipping planes.
    if ( ConeInsidePlane( cone, nearPlane ) || ConeInsidePlane( cone, farPlane ) )
    {
        result = false;
    }
 
    // Then check frustum planes
    for ( int i = 0; i < 4 && result; i++ )
    {
        if ( ConeInsidePlane( cone, frustum.planes[i] ) )
        {
            result = false;
        }
    }
 
    return result;
}

// Add the light to the visible light list for opaque geometry.
void o_AppendLight( uint lightIndex, uint type )
{
    uint index;
    
    switch(type)
    {
        case 0:
            index = atomicAdd(o_LightCount.Point, 1);
            break;
        case 1:
            index = atomicAdd(o_LightCount.Spot, 1);
            break;
        case 2:
            index = atomicAdd(o_LightCount.Dir, 1);
            break;
    }
    
    if ( index < 1024 )
    {
       switch(type)
        {
            case 0:
                o_LightList[index].Point = lightIndex;
                break;
            case 1:
                o_LightList[index].Spot = lightIndex;
                break;
            case 2:
                o_LightList[index].Dir = lightIndex;
                break;
        }
       
    }
}
 
// Add the light to the visible light list for transparent geometry.
void t_AppendLight( uint lightIndex,  uint type )
{
    uint index;
    
    switch(type)
    {
        case 0:
            index = atomicAdd(t_LightCount.Point, 1);
            break;
        case 1:
            index = atomicAdd(t_LightCount.Spot, 1);
            break;
        case 2:
            index = atomicAdd(t_LightCount.Dir, 1);
            break;
    }
    
    if ( index < 1024 )
    {
       switch(type)
        {
            case 0:
                t_LightList[index].Point = lightIndex;
                break;
            case 1:
                t_LightList[index].Spot = lightIndex;
                break;
            case 2:
                t_LightList[index].Dir = lightIndex;
                break;
        }
       
    }
}


vec4 ClipToView( vec4 clip )
{
    // View space position.
    vec4 view = uInverseProjection * clip;
    // Perspective projection.
    view = view / view.w;
    return view;
}

// Convert screen space coordinates to view space.
vec4 ScreenToView( vec4 screen )
{
    // Convert to normalized texture coordinates
    vec2 texCoord = screen.xy / vec2(1280, 720);
    // Convert to clip space
    vec4 clip = vec4( vec2( texCoord.x, 1.0 - texCoord.y ) * 2.0f - 1.0f, screen.z,
    screen.w );
    return ClipToView( clip );
}


void main()
{


    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    float depth =  texelFetch(uDepthTexture, texelCoord, 0).r;
    uint depthu = floatBitsToUint(depth);
   
    if(gl_LocalInvocationIndex == 0)
    {
        uMinDepth = 0xffffffff;
        uMaxDepth = 0;
        o_LightCount.Point = 0;
        o_LightCount.Spot = 0;
        o_LightCount.Dir = 0;

        t_LightCount.Point = 0;
        t_LightCount.Spot = 0;
        t_LightCount.Dir = 0;

        uint index = (gl_WorkGroupID.x + (gl_WorkGroupID.y * gl_NumWorkGroups.x));
        GroupFrustum = in_Frustums[index];
       
    }

   

    groupMemoryBarrier();

    atomicMin(uMinDepth, depthu);
    atomicMax(uMaxDepth, depthu);

    groupMemoryBarrier();

    float fMinDepth = uintBitsToFloat( uMinDepth );
    float fMaxDepth = uintBitsToFloat( uMaxDepth );

    // Convert depth values to view space.
    float minDepthVS = ScreenToView( vec4( 0.0, 0.0, fMinDepth, 1.0 ) ).z;
    float maxDepthVS = ScreenToView( vec4( 0.0, 0.0, fMaxDepth, 1.0 ) ).z;
    float nearClipVS = ScreenToView( vec4( 0.0, 0.0, 0.0, 1.0 ) ).z;
 
    // Clipping plane for minimum depth value 
    // (used for testing lights within the bounds of opaque geometry).
    Plane minPlane = { vec3( 0.0, 0.0, -1.0 ), -minDepthVS };
     

    //point lights
    for ( uint i = gl_LocalInvocationIndex; i < lightCount.Point; i += BLOCK_SIZE * BLOCK_SIZE )
    {
        
   
        Sphere sphere;
        sphere.c = float3ToVec3(in_PointLights[i].PositionVS);
        sphere.r = in_PointLights[i].Distance;


        if(SphereInsideFrustum(sphere, GroupFrustum, nearClipVS, maxDepthVS))
        {
            t_AppendLight(i, 0);

           if ( !SphereInsidePlane( sphere, minPlane ) )
           {
              // Add light to light list for opaque geometry.
              o_AppendLight(i, 0);
           }

        }
    }

    for ( uint i = gl_LocalInvocationIndex; i < lightCount.Spot; i += BLOCK_SIZE * BLOCK_SIZE )
    {
        uint lightIndex = i;
        SpotLight light = in_SpotLights[lightIndex];
        
         float coneRadius = tan( radians( light.InnerAngle ) ) * light.Distance;
         Cone cone = { float3ToVec3(light.PositionVS).xyz, light.Distance, float3ToVec3(light.DirectionVS).xyz, coneRadius };
         if ( ConeInsideFrustum( cone, GroupFrustum, nearClipVS, maxDepthVS ) )
         {
             // Add light to light list for transparent geometry.
             t_AppendLight( lightIndex, 1 );
 
             if ( !ConeInsidePlane( cone, minPlane ) )
             {
                 // Add light to light list for opaque geometry.
                 o_AppendLight(lightIndex, 1 );
             }
          }
       
    }

    for ( uint i = gl_LocalInvocationIndex; i < lightCount.Dir; i += BLOCK_SIZE * BLOCK_SIZE )
    {
         uint lightIndex = i;
         t_AppendLight( lightIndex, 2 );
         o_AppendLight( lightIndex, 2 );
    }

    groupMemoryBarrier();

     if ( gl_LocalInvocationIndex == 0 )
    {
       
     
        //Point Lights
        o_LightIndexStartOffset.Point = atomicAdd(o_LightIndexCounter[0], o_LightCount.Point);
        imageStore(u_oPointLightGrid, ivec2(gl_WorkGroupID.xy), ivec4(vec2( o_LightIndexStartOffset.Point, o_LightCount.Point), 0, 1));

        t_LightIndexStartOffset.Point = atomicAdd(t_LightIndexCounter[0], t_LightCount.Point);
        imageStore(u_tPointLightGrid, ivec2(gl_WorkGroupID.xy), ivec4(vec2( t_LightIndexStartOffset.Point, t_LightCount.Point), 0, 1));

        //Spot Lights
        o_LightIndexStartOffset.Spot = atomicAdd(o_LightIndexCounter[1], o_LightCount.Spot);
        imageStore(u_oSpotLightGrid, ivec2(gl_WorkGroupID.xy), ivec4(vec2( o_LightIndexStartOffset.Spot, o_LightCount.Spot), 0, 1));

        t_LightIndexStartOffset.Spot = atomicAdd(t_LightIndexCounter[1], t_LightCount.Spot);
        imageStore(u_tSpotLightGrid, ivec2(gl_WorkGroupID.xy), ivec4(vec2( t_LightIndexStartOffset.Spot, t_LightCount.Spot), 0, 1));

          //Dir Lights
       o_LightIndexStartOffset.Dir = atomicAdd(o_LightIndexCounter[2], o_LightCount.Dir);
       imageStore(u_oDirLightGrid, ivec2(gl_WorkGroupID.xy), ivec4(vec2( o_LightIndexStartOffset.Dir, o_LightCount.Dir), 0, 1));
       
       t_LightIndexStartOffset.Dir = atomicAdd(t_LightIndexCounter[2], t_LightCount.Dir);
        imageStore(u_tDirLightGrid, ivec2(gl_WorkGroupID.xy), ivec4(vec2( t_LightIndexStartOffset.Dir, t_LightCount.Dir), 0, 1));
         
    }
    
    groupMemoryBarrier();


    //Point Lights
      // Now update the light index list (all threads).
    // For opaque geometry.
    for (uint i = gl_LocalInvocationIndex; i < o_LightCount.Point; i += BLOCK_SIZE * BLOCK_SIZE )
    {
     

        o_LightIndexList[o_LightIndexStartOffset.Point + i].Point = o_LightList[i].Point;
    }
    // For transparent geometry.
    for ( uint i = gl_LocalInvocationIndex; i < t_LightCount.Point; i += BLOCK_SIZE * BLOCK_SIZE )
    {
   
        t_LightIndexList[t_LightIndexStartOffset.Point + i].Point = t_LightList[i].Point;
    }


     if ( gl_LocalInvocationID.x == 0 || gl_LocalInvocationID.y == 0 )
    {
          imageStore(u_tLightHeatMap, ivec2(texelCoord), vec4( 0, 0, 0, 0.9f ));
    }
    else if ( gl_LocalInvocationID.x == 1 || gl_LocalInvocationID.y == 1 )
    {

        imageStore(u_tLightHeatMap, ivec2(texelCoord), vec4( 1, 1, 1, 0.5f ));
      
    } else if(o_LightCount.Point > 0 || o_LightCount.Spot > 0)
    {

         float normalizedPointLightCount = o_LightCount.Point / 50.0f;
         float normalizedSpotLightCount = o_LightCount.Spot / 50.0f;
        imageStore(u_tLightHeatMap, ivec2(texelCoord), vec4(normalizedPointLightCount, normalizedSpotLightCount, 0.0, 1.0));
    } else {
         imageStore(u_tLightHeatMap, ivec2(texelCoord), vec4( 0, 0, 0, 1.0f ));
  
    }
    
    //Spot Lights
    // Now update the light index list (all threads).
    // For opaque geometry.
    for (uint i = gl_LocalInvocationIndex; i < o_LightCount.Spot; i += BLOCK_SIZE * BLOCK_SIZE )
    {
        uint lightIndex = i;
        o_LightIndexList[o_LightIndexStartOffset.Spot + lightIndex].Spot = o_LightList[i].Spot;
    }
    // For transparent geometry.
    for ( uint i = gl_LocalInvocationIndex; i < t_LightCount.Spot; i += BLOCK_SIZE * BLOCK_SIZE )
    {
        uint lightIndex = i;
        t_LightIndexList[t_LightIndexStartOffset.Spot + lightIndex].Spot = t_LightList[i].Spot;
    }


    //DIr lights
    // Now update the light index list (all threads).
    // For opaque geometry.
    for (uint i = gl_LocalInvocationIndex; i < o_LightCount.Dir; i += BLOCK_SIZE * BLOCK_SIZE )
    {
        uint lightIndex = i;
        o_LightIndexList[o_LightIndexStartOffset.Dir + lightIndex].Dir = o_LightList[i].Dir;
    }
    // For transparent geometry.
    for ( uint i = gl_LocalInvocationIndex; i < t_LightCount.Dir; i += BLOCK_SIZE * BLOCK_SIZE )
    {
        uint lightIndex = i;
        t_LightIndexList[t_LightIndexStartOffset.Dir + lightIndex].Dir = t_LightList[i].Dir;
    }

}